<script defer src="//meta.cdn.bubble.io/f1678588430465x230578802325048350/icons.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    let allSelect = /\[(hi.*)\](.*)\[\/(hi.*)\]/;
    let colormatch = /#[0-9A-f]{3,6}#/;
    let fillMatcher = /fill="currentColor"/;

    function replaceIcon(btn) {
      const btn_nodes = Array.from(btn.childNodes);
        
      if (!btn_nodes) return;
        
      const text_node = btn_nodes.find((node) => node.nodeName === "#text");
      
      if (!text_node) return;
      
      let content = text_node.data;
      let iconColor = content.match(colormatch);
      content = content.replace(colormatch, "");
      
      const iconMarkup = content.match(allSelect);
      
      if (!iconMarkup) return; // if there's no icon in this button, just return.

      if (iconMarkup[1] != iconMarkup[3]) return; // return if both opening and closing tags do not match

      const iconProps = iconMarkup[1].slice(2).split("-"); // remove hi and separate props by -

      const props = {
        name: iconMarkup[2],
        size: undefined,
        color: btn.innerHTML.match(colormatch) ? btn.innerHTML.match(colormatch)[0].slice(0, -1) : undefined,
        set: "mini",
        position: undefined,
        iconHTML: undefined,
        style: 'style="',
      };

      if (props.color) {
        props.iconHTML = props.iconHTML.replace(fillMatcher, "fill=" + iconColor);
      }
        
      iconProps.forEach((property) => {
        switch (property) {
          case "l":
            props.position = "left";
            break;
          case "r":
            props.position = "right";
            break;
          case "b":
            props.position = "center";
            break;
          case "o":
            props.set = "outlined";
            break;
          case "s":
            props.set = "solid";
            break;
        }
          
        const number = Number(property);
          
        if (number && number > 0) {
          props.size = String(number) + "px";
        }
      });

      if (window[`heroicons_${props.set}`].has(props.name)) {
        props.iconHTML = window[`heroicons_${props.set}`].get(props.name);
      } else {
        console.log("Did not find applicable heroicon!");
        return;
      }
      
      btn.classList.add("heroicon");
        
      const default_size = "20px";

      props.style += `height: ${props.size ?? default_size}; width: ${props.size ?? default_size};`;

      let insertBefore = props.iconHTML.lastIndexOf("viewBox");

      btn.childNodes.forEach((node) => {
        if (node.nodeName === "#text") {
          node.data = node.data.replace(allSelect, "");
        }
      });

      btn.childNodes.forEach((node) => {
        if (node.nodeName !== "#text") {
          node.remove();
        }
      });

      if (props.position == "left") {
        let styledHTML =
          props.iconHTML.substring(0, insertBefore) +
          props.style +
          `margin-right:8px"` +
          props.iconHTML.substring(insertBefore);
        btn.insertAdjacentHTML("afterbegin", styledHTML);
      } else if (props.position == "right") {
        let styledHTML =
          props.iconHTML.substring(0, insertBefore) +
          props.style +
          `margin-left:8px"` +
          props.iconHTML.substring(insertBefore);
        btn.insertAdjacentHTML("beforeend", styledHTML);
      } else {
        let styledHTML =
          props.iconHTML.substring(0, insertBefore) + props.style + `"` + props.iconHTML.substring(insertBefore);
        btn.insertAdjacentHTML("beforeend", styledHTML);
      }
    }

    let config = {
      subtree: true,
      childList: true,
      attributes: false,
      characterData: true,
    };

    let callback = function (mutationsList, observer) {

      for (let mutation of mutationsList) {
        if (mutation.target.tagName === "BUTTON") {
          replaceIcon(mutation.target);
        }

        if (mutation.addedNodes) {
          mutation.addedNodes.forEach((node) => {
            if (node.tagName == "BUTTON") {
              replaceIcon(node);
            }
          });
        }

        if (
          mutation.target.nodeName === "#text" &&
          mutation.target.parentElement &&
          mutation.target.parentElement.tagName === "BUTTON"
        ) {
          replaceIcon(mutation.target.parentElement);
        }
      }
    };

    const observer = new MutationObserver(callback);
    observer.observe(document, config);
  });
</script>

<style>
  .animate-spin > circle {
    color: inherit;
    opacity: 25%
  }

  .animate-spin {
    animation: 1s linear infinite spin
  }

  @keyframes spin {
    from {
      transform: rotate(0)
    }

    to {
      transform: rotate(360deg)
    }
  }
  
  .heroicon {
    display: inline-flex;
    vertical-align: middle;
    justify-content: center;
    align-items: center;
  }
    
  .dots_one {
    animation: dots 0.8s linear infinite;
    animation-delay: -0.8s;
  }

  .dots_two {
    animation-delay: -0.65s;
  }

  .dots_three {
    animation-delay: -0.5s;
  }

  @keyframes dots {
    93.75%,
    100% {
      opacity: 0.2;
    }
  }
</style>